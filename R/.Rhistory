}
source("scripts/Scenarios.R")
source("scripts/estimand functions.R")
#### Load data #####
data_dir <- "Data/simulation data/scenario 1/"
data_files <- list.files(path = data_dir, recursive = T, full.names = F)
df <- lapply(paste0(data_dir,data_files),readRDS,.GlobalEnv)
test <- lapply(df, get_app_results, df = df, model = "OLS")
get_app_results <- function(df, model = c("OLS", "Firth")){
if (model == "OLS"){
fit_app <- glm(y~., family = "binomial", data = df) #%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
} else {
fit_app <- logistf(y~., data = df, flic = T)
}
p_app <- predict(fit_app, type="response")
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app<- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <- calib(modelmatrix = model.matrix(fit_app), data = df, coefs = fit_app$coefficients)
eci_app <- eci_bvc(data = df, modelmatrix = model.matrix(fit_app), coefs = fit_app$coefficients, preds = p_app)
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
return(results)
}
test <- lapply(df, get_app_results, df = df, model = "OLS")
test <- lapply(df, get_app_results, model = "OLS")
View(test)
system.time(test <- lapply(df, get_app_results, model = "OLS")) # Need to get s1 in here somewhere
length(df)
i <- 1
s1[i,]$model
for (i in 1:length(df)){
model <- as.character(s1[i,]$model)
test[[i]] <- get_app_results(df = df[[i]], model = model)
}
############ Load necessary stuff ############
source("scripts/libraries.R")
system.time(for (i in 1:length(df)){
model <- as.character(s1[i,]$model)
test[[i]] <- get_app_results(df = df[[i]], model = model)
}
)
df[[i]]
?logistf
View(test)
View(test)
fit_app <- logistf(y ~ ., data = df[[1]], flic = T)
fit_app$model
model.matrix(fit_app)
model.matrix(fit_app)
X <- model.matrix(object = fit_app$formula, data = df[[1]])
View(X)
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
###### Apparent performance ######
## Depends on which model is used.
get_app_results <- function(scenarios, df) {
results_app <- list()
.get_app_estimands <- function(df) {
# Fit model depending on scenario
# And get predicted probabilities
if (model == "OLS") {
fit_app <- glm(y ~ ., family = "binomial", data = df)
#%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
p_app <- predict(fit_app, type = "response")
} else {
fit_app <- logistf(y ~ ., data = df[[1]], flic = T)
X <- model.matrix(object = fit_app$formula, data = df[[1]])
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
}
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = model.matrix(fit_app),
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = model.matrix(fit_app),
coefs = fit_app$coefficients,
preds = p_app
)
# Save results
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
}
for (i in 1:length(df)) {
model <- s1[i, ]$model
results_app[[i]] <-
.get_app_estimands(df = df[[i]], model = model)
}
return(results_app)
}
results_app <- get_app_results(scenarios = s1, df = df)
###### Apparent performance ######
## Depends on which model is used.
get_app_results <- function(scenario, df) {
results_app <- list() #object to store results
.get_app_estimands <- function(df, model) {
# Fit model depending on scenario
# And get predicted probabilities
if (model == "OLS") {
fit_app <- glm(y ~ ., family = "binomial", data = df) #%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
p_app <- predict(fit_app, type = "response")
} else { # If model = Firth (or svm for now)
fit_app <- logistf(y ~ ., data = df[[1]], flic = T)
X <- model.matrix(object = fit_app$formula, data = df[[1]])
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
}
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = model.matrix(fit_app),
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = model.matrix(fit_app),
coefs = fit_app$coefficients,
preds = p_app
)
# Save results
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
}
for (i in 1:length(df)) {
model <- s1[i, ]$model
results_app[[i]] <-
.get_app_estimands(df = df[[i]], model = model)
}
return(results_app)
}
results_app <- get_app_results(scenario = s1, df = df)
###### Apparent performance ######
## Depends on which model is used.
get_app_results <- function(scenario, df) {
results_app <- list() #object to store results
.get_app_estimands <- function(df, model) {
# Fit model depending on scenario
# And get predicted probabilities
if (model == "OLS") {
fit_app <- glm(y ~ ., family = "binomial", data = df) #%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
p_app <- predict(fit_app, type = "response")
} else { # If model = Firth (or svm for now)
fit_app <- logistf(y ~ ., data = df[[1]], flic = T)
X <- model.matrix(object = fit_app$formula, data = df[[1]])
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
}
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = model.matrix(fit_app),
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = model.matrix(fit_app),
coefs = fit_app$coefficients,
preds = p_app
)
# Save results
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
}
for (i in 1:length(df)) {
model <- s1[i, ]$model
results_app[[i]] <-
.get_app_estimands(df = as.data.frame(df[[i]]), model = model)
}
return(results_app)
}
results_app <- get_app_results(scenario = s1, df = df)
results_app <- get_app_results(scenario = s1, df = df[[1]])
results_app <- get_app_results(scenario = s1, df = as.data.frame(df[[1]]))
###### Apparent performance ######
## Depends on which model is used.
get_app_estimands <- function(df, model) {
# Fit model depending on scenario
# And get predicted probabilities
if (model == "OLS") {
fit_app <- glm(y ~ ., family = "binomial", data = df) #%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
p_app <- predict(fit_app, type = "response")
} else { # If model = Firth (or svm for now)
fit_app <- logistf(y ~ ., data = df[[1]], flic = T)
X <- model.matrix(object = fit_app$formula, data = df[[1]])
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
}
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = model.matrix(fit_app),
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = model.matrix(fit_app),
coefs = fit_app$coefficients,
preds = p_app
)
# Save results
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
}
system.time(test <- lapply(df, get_app_estimands, model = "OLS")) # Need to get s1 in here somewhere
View(test)
system.time(test <- lapply(df, get_app_estimands, model = "Firth")) # Need to get s1 in here somewhere
###### Apparent performance ######
## Depends on which model is used.
get_app_estimands <- function(df, model) {
# Fit model depending on scenario
# And get predicted probabilities
if (model == "OLS") {
fit_app <- glm(y ~ ., family = "binomial", data = df) #%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
p_app <- predict(fit_app, type = "response")
} else { # If model = Firth (or svm for now)
fit_app <- logistf(y ~ ., data = df, flic = T)
X <- model.matrix(object = fit_app$formula, data = df)
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
}
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = model.matrix(fit_app),
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = model.matrix(fit_app),
coefs = fit_app$coefficients,
preds = p_app
)
# Save results
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
}
system.time(test <- lapply(df, get_app_estimands, model = "Firth")) # Need to get s1 in here somewhere
df <- df[[1]]
fit_app <- logistf(y ~ ., data = df, flic = T)
X <- model.matrix(object = fit_app$formula, data = df)
p_app <- 1 / (1 + exp(-X %*% fit_app$coefficients))
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = model.matrix(fit_app),
data = df,
coefs = fit_app$coefficients
)
fit_app <- logistf(y ~ ., data = df, flic = T)
app_matrix <- model.matrix(object = fit_app$formula, data = df)
p_app <- 1 / (1 + exp(-app_matrix %*% fit_app$coefficients))
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = app_matrix,
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = app_matrix,
coefs = fit_app$coefficients,
preds = p_app
)
###### Apparent performance ######
## Depends on which model is used.
get_app_estimands <- function(df, model) {
# Fit model depending on scenario
# And get predicted probabilities
if (model == "OLS") {
fit_app <- glm(y ~ ., family = "binomial", data = df) #%>%
#step(direction = "backward", trace = F) # This should be changeable depending on which thing you're using
p_app <- predict(fit_app, type = "response")
app_matrix <- model.matrix(fit_app)
} else { # If model = Firth (or svm for now)
fit_app <- logistf(y ~ ., data = df, flic = T)
app_matrix <- model.matrix(object = fit_app$formula, data = df)
p_app <- 1 / (1 + exp(-app_matrix %*% fit_app$coefficients))
}
# Performance measures
auc_app <- fastAUC(p = p_app, y = df$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = df$y)
calib_app <-
calib(
modelmatrix = app_matrix,
data = df,
coefs = fit_app$coefficients
)
eci_app <-
eci_bvc(
data = df,
modelmatrix = app_matrix,
coefs = fit_app$coefficients,
preds = p_app
)
# Save results
results <-
c(
"AUC_app" = auc_app,
"calib_int_app" = calib_app['intercept'],
"calib_slope_app" = calib_app['slope'],
"R2_cox_snell_app" = R2_app,
"ECI_app" = eci_app
)
}
get_app_results <- function(scenario, df) {
results_app <- list() #object to store results
for (i in 1:length(df)) {
model <- s1[i, ]$model
results_app[[i]] <- get_app_estimands(df = as.data.frame(df[[i]]), model = model)
}
return(results_app)
}
df <- lapply(paste0(data_dir,data_files),readRDS,.GlobalEnv)
results_app <- get_app_results(scenario = s1, df = df)
View(results_app)
system.time(test <- lapply(df, get_app_estimands, model = "Firth")) # Need to get s1 in here somewhere
sytem.time(results_app <- get_app_results(scenario = s1, df = df))
system.time(results_app <- get_app_results(scenario = s1, df = df))
system.time(test <- lapply(df, get_app_estimands, model = "OLS")) # Need to get s1 in here somewhere
model_svm <- caret::train(
y ~ .,
data = df[[1]],
method = "svmRadial",
#trControl = trainControl(method = "cv", number = 10),
tuneLength = 10
)
model_svm <- caret::train(
y ~ .,
data = df[[1]],
method = "svmRadial",
#trControl = trainControl(method = "cv", number = 10),
tuneLength = 10
)
###### try-out svm tuning ######
model_svm <- caret::train(
y ~ .,
data = df[[1]],
method = "svmRadial",
#trControl = trainControl(method = "cv", number = 10),
tuneLength = 10
)
###### try-out svm tuning ######
model_svm <- caret::train(
as.factor(y) ~ .,
data = df[[1]],
method = "svmRadial",
#trControl = trainControl(method = "cv", number = 10),
tuneLength = 10
)
library(e1071)
?tune.svm
###### try-out svm tuning ######
test <- df[[1]]
test_svm <- tune.svm(formula = y ~ ., data = test, ranges = list(gamma = 2^(-1:1), cost = 2^(2:4)),
tunecontrol = tune.control(sampling = "fix"))
###### try-out svm tuning ######
test <- df[[1]]
test_svm <- tune.svm(y~., data = test, gamma = 2^(-1:1), cost = 2^(2:4))
test_svm$best.model
best.tune(test_svm)
predict(test_svm$best.model, test)
predict(test_svm$best.model, test, probability = T)
p_app <- predict(test_svm$best.model, test, probability = T)
auc_app <- fastAUC(p = p_app, y = test$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = test$y)
test_svm$best.model
test_svm$best.performance
test_svm$performances
p_app <- predict(test_svm$best.model, test, probability = T)
auc_app <- fastAUC(p = p_app, y = test$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = test$y)
c.stat2(preds = p_app, outcome = test$y)
coef(test_svm$best.model)
test_svm <- tune.svm(y~., data = test, gamma = 2^(-1:1), cost = 2^(2:4), kernel = "linear")
test_svm$best.model
p_app <- predict(test_svm$best.model, test, probability = T)
test_svm$best.model
auc_app <- fastAUC(p = p_app, y = test$y)
auc_app <- fastAUC(p = p_app, y = test$y)
R2_app <- pseudo_Rsqrs(p = p_app, y = test$y)
p_app
coef(test_svm$best.model)
test_svm$best.parameters
as.formula(y~coef(test_svm$best.model)
as.formula(y~coef(test_svm$best.model))
as.formula(y~coef(test_svm$best.model))
as.formula(coef(test_svm$best.model))
formula(coef(test_svm))
formula(coef(test_svm$best.model))
formula(y,coef(test_svm$best.model))
formula(y~coef(test_svm$best.model))
test_svm <- tune.svm(y~., data = test, scale = F, gamma = 2^(-1:1), cost = 2^(2:4), kernel = "linear")
##################################
##################################
##################################
## get estimands 1 scenario:
set.seed(123)
############ Load necessary stuff ############
source("scripts/libraries.R")
source("scripts/Scenarios.R")
source("scripts/estimand functions.R")
#### Load data #####
data_dir <- "Data/simulation data/scenario 1/"
data_files <- list.files(path = data_dir, recursive = T, full.names = F)
df <- lapply(paste0(data_dir,data_files),readRDS,.GlobalEnv)
system.time(results_app <- get_app_results(scenario = s1, df = df))
source("scripts/estimand functions.R")
#### Load data #####
data_dir <- "Data/simulation data/scenario 1/"
data_files <- list.files(path = data_dir, recursive = T, full.names = F)
df <- lapply(paste0(data_dir,data_files),readRDS,.GlobalEnv)
system.time(results_app <- get_app_results(scenario = s1, df = df))
system.time(results_app <- get_app_results(scenario = s1, df = df))
View(results_app)
source("scripts/estimand functions.R")
system.time(results_app <- get_app_results(scenario = s1, df = df))
View(results_app)
################# INITIAL SETUP ##################
## Script to define paths to the simulated data ##
##################################################
source("scripts/libraries.R")
source("scripts/scenarios.R")
.GlobalEnv
ls.str(.GlobalEnv)
str(.GlobalEnv)
ls(.GlobalEnv)
###
scenario_setting_path <- "Data/Simulation settings/Scenario 1"
source("scripts/Setup.R")
set.seed(123)
source("scripts/Setup.R")
source("scripts/Data generation functions.R")
write_rds(s1, file = past0(scenario_setting_path, "Scenario 1/s1.Rds"))
write_rds(s1, file = paste0(scenario_setting_path, "Scenario 1/s1.Rds"))
source("scripts/Setup.R")
source("scripts/Setup.R")
i <- 1
paste0(scenario_1_data, "s1_data_", i,".Rds"))
paste0(scenario_1_data, "s1_data_", i,".Rds")
read_rds(paste0(scenario_1_settings,"s1.Rds"))
s1 <- read_rds(paste0(scenario_1_settings,"s1.Rds"))
system.time(s1_data <- generate_data(s1)) ##### ALSO DEFINE VALIDATION SET!
lapply(lapply(s1_data,'[[', 11), mean) # check whether the prevalence is somewhat okay
paste0(scenario_1_settings,"Betas/Betas_prev_0.05_halfstrong.Rds")
beta_0.2 <- readRDS(paste0(scenario_1_settings,"Betas/Betas_prev_0.2_halfstrong.Rds"))
beta_0.05 <- readRDS(paste0(scenario_1_settings,"Betas/Betas_prev_0.05_halfstrong.Rds"))
write_rds(s1, file = paste0(scenario_1_settings, "s1.Rds"))
