# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- exp(glm_fit$coefficients[1]) / (1 + exp(glm_fit$coefficients[1]))
obs_cstat
obs_prev
exp(glm_fit$coefficients[1])
glm_fit$coefficients[1]
exp(glm_fit$coefficients[1]) / (1 + exp(glm_fit$coefficients[1]))
sigma <- matrix(0.2, ncol = 3, nrow = 3) # create covariance matrix to be used as input
diag(sigma) <- 1 # set the diagonal to 1
mu <- rep(1, 3) # provide a vector of mu
n <- 1000
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
dm <- cbind(1, X)
dgm_par_i <- c(0.2, rep(0.3, 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par_i)/(1+exp(dm %*% dgm_par_i))
y <- rbinom(length(p),1,p)
glm_fit_i <- glm(y ~ X, family = "binomial")
obs_p <- predict(fit_i, type =  "response")
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- exp(fit_i$coefficients[1]) / (1 + exp(fit_i$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
func <- function(par){
# What are the values we are looking for?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
dgm_par <- c(results[1], rep(results[2], 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- exp(glm_fit$coefficients[1]) / (1 + exp(glm_fit$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
}
results <- optim(c(0.2, 0.4), func)$par
func(par = results)
func <- function(par){
# What are the values we are looking for?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- exp(glm_fit$coefficients[1]) / (1 + exp(glm_fit$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
}
results <- optim(c(0.2, 0.4), func)$par
func(par = results)
optim(c(0.2, 0.8), func)$par
optim(c(1.3, 0.8), func)$par
results <- optim(c(1.3, 0.8), func)$par
exp(results[1]) / (1 + exp(results$coefficients[1]))
exp(results[1]) / (1 + exp(results[1]))
results <- optim(c(0.01, 0.8), func)$par
func(par = results)
exp(results[1]) / (1 + exp(results[1]))
obs_p
mean(obs_p)
exp(fit_glm$coefficients[1]) / (1 + exp(fit_glm$coefficients[1]))
exp(glm_fit$coefficients[1]) / (1 + exp(glm_fit$coefficients[1]))
exp(results[1]) / (1 + exp(results[1]))
# Providing the beta0 and beta1-3 as specified in the par object.
dgm_par <- c(results[1], rep(results[2], 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- mean(obs_p)
mean(obs_p)
exp(results[1]) / (1 + exp(results[1]))
View(glm_fit)
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
abs(obs_cstat-pref_cstat)
results <- optim(c(0.3, 0.8), func)$par
func(par = results)
optim(c(0.3, 0.8), func)
optim(c(0.6, 0.8), func)
optim(c(0.4, 0.8), func)
optim(c(0.4, 0.4), func)
optim(c(0.2, 0.4), func)
func(par = results)
optim(c(0.2, 0.4), func)
library(pmsampsize)
library(MASS)
library(tidyverse)
library(pmsampsize)
?pmsampsize
library(rms)
######## Sample size #######
approximate_R2 <- function(auc, prev, n = 1000000){
# define mu as a function of the C statistic
mu <- sqrt(2) * qnorm(auc)
# simulate large sample linear prediction based on two normals
# for non-eventsN(0, 1), events and N(mu, 1)
LP <- c(rnorm(prev*n, mean=0, sd=1), rnorm((1-prev)*n, mean=mu, sd=1))
y <- c(rep(0, prev*n), rep(1, (1-prev)*n))
# Fit a logistic regression with LP as covariate;
# this is essentially a calibration model, and the intercept and
# slope estimate will ensure the outcome proportion is accounted
# for, without changing C statistic
fit <- lrm(y~LP)
max_R2 <- function(prev){
1-(prev^prev*(1-prev)^(1-prev))^2
}
return(list(R2.nagelkerke = as.numeric(fit$stats['R2']),
R2.coxsnell = as.numeric(fit$stats['R2']) * max_R2(prev)))
}
test <- approximate_R2(auc = 0.75, prev = 0.2)
pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = 0.126)
pmsampsize(type = "b", parameters = 10, prevalence = 0.2, rsquared = 0.126)
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = 0.126)
View(n)
n[["results_table"]]
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = 0.126)$sampsize
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = 0.126)
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = 0.126)$sample_size
prev_.05 <- approximate_R2(auc = 0.75, prev = 0.05)
prev_.2 <- approximate_R2(auc = 0.75, prev = 0.2)$R2.coxsnell
prev_.05 <- approximate_R2(auc = 0.75, prev = 0.05)$R2.coxsnell
Rcs_prev_.2 <- approximate_R2(auc = 0.75, prev = 0.2)$R2.coxsnell
Rcs_prev_.05 <- approximate_R2(auc = 0.75, prev = 0.05)$R2.coxsnell
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = Rcs_prev_.05)$sample_size
################### Setting up #############################
library(MASS)
library(tidyverse)
library(pmsampsize)
library(rms)
#### Functions #####
c_stat2 <- function(preds, outcome){
preds <- as.matrix(preds)
cats <- sort(unique(outcome))
n_cat <- length(cats)
n0   <- sum(outcome == cats[2])
n1   <- length(outcome) - n0
r <- rank(preds[,1])
S0 <- sum(as.numeric(r[outcome == cats[2]]))
(S0 - n0 * (n0 + 1)/2)/(as.numeric(n0) * as.numeric(n1))
}
######## Sample size #######
## Approximate R^2 from a desired AUC of 0.75 and prev of 0.2 & 0.05
approximate_R2 <- function(auc, prev, n = 1000000){
# define mu as a function of the C statistic
mu <- sqrt(2) * qnorm(auc)
# simulate large sample linear prediction based on two normals
# for non-eventsN(0, 1), events and N(mu, 1)
LP <- c(rnorm(prev*n, mean=0, sd=1), rnorm((1-prev)*n, mean=mu, sd=1))
y <- c(rep(0, prev*n), rep(1, (1-prev)*n))
# Fit a logistic regression with LP as covariate;
# this is essentially a calibration model, and the intercept and
# slope estimate will ensure the outcome proportion is accounted
# for, without changing C statistic
fit <- lrm(y~LP)
max_R2 <- function(prev){
1-(prev^prev*(1-prev)^(1-prev))^2
}
return(list(R2.nagelkerke = as.numeric(fit$stats['R2']),
R2.coxsnell = as.numeric(fit$stats['R2']) * max_R2(prev)))
}
Rcs_prev_.2 <- approximate_R2(auc = 0.75, prev = 0.2)$R2.coxsnell
Rcs_prev_.05 <- approximate_R2(auc = 0.75, prev = 0.05)$R2.coxsnell
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = Rcs_prev_.05)$sample_size
n <- pmsampsize(type = "b", parameters = 3, prevalence = 0.2, rsquared = Rcs_prev_.2)$sample_size
sigma <- matrix(0.2, ncol = 3, nrow = 3) # create covariance matrix to be used as input
diag(sigma) <- 1 # set the diagonal to 1
mu <- rep(1, 3) # provide a vector of mu
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
dm <- cbind(1, X)
dgm_par_i <- c(0.2, rep(0.3, 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par_i)/(1+exp(dm %*% dgm_par_i))
y <- rbinom(length(p),1,p)
glm_fit_i <- glm(y ~ X, family = "binomial")
obs_p <- predict(fit_i, type =  "response")
obs_p <- predict(glm_fit_i, type =  "response")
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))
obs_prev <- 1 / (1 + exp(-glm_fit_i$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
pref_cstat <- 0.75
pref_prev <- .2
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev)^2)
abs(obs_prev-pref_prev)
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), 2*abs(obs_prev-pref_prev))
##### Putting the above together:
func <- function(par){
# What are the values we are looking for?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), 2*abs(obs_prev-pref_prev))
}
optim(c(0.2, 0.4), func)
optim(c(0.4, 0.4), func)
optim(c(1, 0.4), func)
optim(c(0.2, 0.4), func)
##### Putting the above together:
func <- function(par){
# What are the values we are looking for?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain initial values for the y
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = obs_p, outcome = y)
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
}
optim(c(0.2, 0.4), func)
func(par = results)
optim(c(0.2, 0.4), func)
mu <- c(1,2, 3) # provide a vector of values for mu
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
dm <- cbind(1, X)
n <- 10000 #setting n
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
c_stat2(preds = p, outcome = y)
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
# What are the preferred values of the c-statistic and prevalence?
pref_cstat <- 0.75
pref_prev <- 0.2
##########################################
##########################################
##########################################
## Defining a function to get the sum of absolute
## differences between the preferred and observed
## values of both the C-statistic and prevalence
par <- c(0.2,0.4)
# What are the preferred values of the c-statistic and prevalence?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
# Again, beta1-3 are restricted to be equal.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
sigma <- matrix(0.2, ncol = 3, nrow = 3) # create covariance matrix to be used as input
diag(sigma) <- 1 # set the diagonal to 1
mu <- c(1,2, 3) # provide a vector of values for mu
n <- 10000 #setting n
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
dm <- cbind(1, X) # Putting the above in a data matrix, including intercept
# What are the preferred values of the c-statistic and prevalence?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
# Again, beta1-3 are restricted to be equal.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
# Obtain observed values
obs_cstat <- c_stat2(preds = p, outcome = y)
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
optim(c(0.2, 0.4), func)
results <- optim(c(0.2, 0.4), func)
func(results$par)
test <- func(results$par)
results <- (optim(c(0.2, 0.4), func))$par
# Providing the beta0 and beta1-3 as specified in the par object.
# Again, beta1-3 are restricted to be equal.
dgm_par <- c(results[1], rep(results[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
# Obtain observed values
obs_cstat <- c_stat2(preds = p, outcome = y)
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
1 / (1 + exp(-glm_fit$coefficients[1]))
c_stat2(preds = p, outcome = y)
optim(c(12, 3), func)
func <- function(par){
# par is a vector with initial guesses for both
# the intercept and the beta1-3 coefficients.
# However since beta1-3 have been restricted to be equal
# only one value is necessary.
# What are the preferred values of the c-statistic and prevalence?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
# Again, beta1-3 are restricted to be equal.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
#obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = p, outcome = y) # obtain c-statistic based on p and y
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1])) #transform the log-odds to probability
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
}
optim(c(12, 3), func)
optim(c(3, 3), func)
optim(c(0.5, 0.5), func)
results <- optim(c(0.5, 0.5), func)
## What do the observed prevalence and c-statistic look like?
dgm_par <- c(results$par[1], rep(results$par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
# Obtain observed values
obs_cstat <- c_stat2(preds = p, outcome = y) # obtain c-statistic based on p and y
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1])) #transform the log-odds to probability
# Obtain observed values
(obs_cstat <- c_stat2(preds = p, outcome = y)) # obtain c-statistic based on p and y
(obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))) #transform the log-odds to probability
library(MASS)
library(tidyverse)
library(pmsampsize)
library(rms)
set.seed(123)
#### Functions #####
c_stat2 <- function(preds, outcome){
preds <- as.matrix(preds)
cats <- sort(unique(outcome))
n_cat <- length(cats)
n0   <- sum(outcome == cats[2])
n1   <- length(outcome) - n0
r <- rank(preds[,1])
S0 <- sum(as.numeric(r[outcome == cats[2]]))
(S0 - n0 * (n0 + 1)/2)/(as.numeric(n0) * as.numeric(n1))
}
#######################
### data generation ###
#######################
sigma <- matrix(0.2, ncol = 3, nrow = 3) # create covariance matrix to be used as input
diag(sigma) <- 1 # set the diagonal to 1
mu <- c(1,2, 3) # provide a vector of values for mu
n <- 10000 #setting n
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
dm <- cbind(1, X) # Putting the above in a data matrix, including intercept
func <- function(par){
# par is a vector with initial guesses for both
# the intercept and the beta1-3 coefficients.
# However since beta1-3 have been restricted to be equal
# only one value is necessary.
# What are the preferred values of the c-statistic and prevalence?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
# Again, beta1-3 are restricted to be equal.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
#obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
obs_cstat <- c_stat2(preds = p, outcome = y) # obtain c-statistic based on p and y
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1])) #transform the log-odds to probability
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
}
results <- optim(c(0.5, 0.5), func)
## Try to optimize using initial guesses 0.5 and 0.5
(results <- optim(c(0.5, 0.5), func))
## What do the observed prevalence and c-statistic look like?
dgm_par <- c(results$par[1], rep(results$par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
# Obtain observed values
(obs_cstat <- c_stat2(preds = p, outcome = y)) # obtain c-statistic based on p and y
(obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))) #transform the log-odds to probability
#############################
### try-out simulate data ###
#############################
################### Setting up #############################
library(MASS)
library(tidyverse)
library(pmsampsize)
library(rms)
set.seed(123)
#### Functions #####
c_stat2 <- function(preds, outcome){
preds <- as.matrix(preds)
cats <- sort(unique(outcome))
n_cat <- length(cats)
n0   <- sum(outcome == cats[2])
n1   <- length(outcome) - n0
r <- rank(preds[,1])
S0 <- sum(as.numeric(r[outcome == cats[2]]))
(S0 - n0 * (n0 + 1)/2)/(as.numeric(n0) * as.numeric(n1))
}
#######################
### data generation ###
#######################
sigma <- matrix(0.2, ncol = 3, nrow = 3) # create covariance matrix to be used as input
diag(sigma) <- 1 # set the diagonal to 1
mu <- c(1,2, 3) # provide a vector of values for mu
n <- 10000 #setting n
X <- mvrnorm(n = n, mu = mu, Sigma = sigma) # create 3 predictor columns
dm <- cbind(1, X) # Putting the above in a data matrix, including intercept
##########################################
##########################################
##########################################
## Defining a function to get the sum of absolute
## differences between the preferred and observed
## values of both the C-statistic and prevalence
func <- function(par){
# par is a vector with initial guesses for both
# the intercept and the beta1-3 coefficients.
# However since beta1-3 have been restricted to be equal
# only one value is necessary.
# What are the preferred values of the c-statistic and prevalence?
pref_cstat <- 0.75
pref_prev <- 0.2
# Providing the beta0 and beta1-3 as specified in the par object.
# Again, beta1-3 are restricted to be equal.
dgm_par <- c(par[1], rep(par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability
glm_fit <- glm(y ~ X, family = "binomial")
#obs_p <- predict(glm_fit, type =  "response")
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Not sure for the c-statistic whether I need to use obs_p or p? #
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Obtain observed values of c-statistic and
# average predicted probability of an event
obs_cstat <- c_stat2(preds = p, outcome = y) # obtain c-statistic based on p and y
obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1])) #transform the log-odds to probability
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Maybe a dumb question, but is this the way to get the average predicted probability for an event? #
#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
# Sum of absolute differences of both values:
sum(abs(obs_cstat-pref_cstat), abs(obs_prev-pref_prev))
}
## Try to optimize using initial guesses 0.5 and 0.5
(results <- optim(c(0.5, 0.5), func))
###################
## check results ##
###################
## What do the observed prevalence and c-statistic look like?
dgm_par <- c(results$par[1], rep(results$par[2], 3))
# Obtain values for y based on Bernoulli distribution, with input p
p <- exp(dm %*% dgm_par)/(1+exp(dm %*% dgm_par))
y <- rbinom(length(p),1,p)
# fit a model to retrieve predicted probability (for c-statistic)
glm_fit <- glm(y ~ X, family = "binomial")
#obs_p <- predict(glm_fit, type =  "response")
# Obtain observed values
(obs_cstat <- c_stat2(preds = p, outcome = y)) # obtain c-statistic based on p and y
(obs_prev <- 1 / (1 + exp(-glm_fit$coefficients[1]))) #transform the log-odds to probability
